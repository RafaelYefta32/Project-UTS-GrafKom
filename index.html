<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Visualisasi Insertion Sort</title>

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Tetap gunakan style.css -->
  <link rel="stylesheet" href="style.css" />
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;700&display=swap"
    rel="stylesheet" />
</head>

<body
  class="bg-gradient-to-br from-white via-sky-50 to-blue-100 text-gray-800 flex flex-col gap-6 p-6 h-screen font-[Plus_Jakarta_Sans]">
  <!-- Judul -->
  <div
    class="title text-3xl font-semibold text-center text-transparent bg-clip-text bg-gradient-to-r from-sky-600 via-blue-600 to-indigo-700 drop-shadow-sm">
    Visualisasi Insertion Sort</div>

  <!-- Kontainer utama -->
  <div class="main-container flex flex-1 gap-6 overflow-hidden">
    <!-- Kiri -->
    <div class="left flex-1 rounded-2xl bg-white border border-blue-200 flex items-center justify-center">
      <canvas id="canva1" class="rounded-lg w-full h-full"></canvas>
    </div>

    <!-- Kanan -->
    <div class="right w-[25%] rounded-2xl bg-white border border-blue-200 flex flex-col overflow-hidden">
      <div class="right-col1 flex flex-col gap-5 p-6 overflow-y-auto overflow-x-hidden" style="max-height: 100%;">
        <div class="text-xl font-semibold text-blue-700 mb-2">Pengaturan</div>

        <!-- Input N -->
        <div class="flex flex-col gap-2">
          <label for="inputN" class="text-sm font-medium text-gray-700">Jumlah Elemen Random (N):</label>
          <input type="number" id="inputN" min="1" value="5" max="50"
            class="border border-gray-300 rounded-lg px-3 py-2 transition-all focus:ring-2 focus:ring-sky-400 focus:border-sky-400 outline-none" />
          <script>
            const input_N = document.getElementById("inputN");
            const max = parseInt(input_N.max);
            const min = parseInt(input_N.min);

            input_N.addEventListener("input", () => {
              let val = parseInt(input_N.value);
              if (val > max) {
                input_N.value = max;
              }
              if (val < min) {
                input_N.value = min;
              }
            });
          </script>
          <p class="text-xs text-gray-500 italic">Batas nilai N : 50</p>
          <div class="flex gap-2 mt-2">
            <button id="manyDuplicateBtn"
              class="flex-1 py-2 rounded-md text-sm font-semibold text-white bg-gradient-to-r from-blue-500 to-sky-500 hover:scale-105 transition-transform">Banyak
              Duplikat</button>
            <button id="uniqueBtn"
              class="flex-1 py-2 rounded-md text-sm font-semibold text-white bg-gradient-to-r from-blue-500 to-sky-500 hover:scale-105 transition-transform">Unik</button>
          </div>
        </div>

        <!-- Input A -->
        <div class="flex flex-col gap-2">
          <label for="inputA" class="text-sm font-medium text-gray-700">Nilai Manual (A):</label>
          <input type="text" id="inputA" value="10,20,30,40,50" autocomplete="off"
            class="border border-gray-300 rounded-lg px-3 py-2 transition-all focus:ring-2 focus:ring-sky-400 focus:border-sky-400 outline-none" />
          <p class="text-xs text-gray-500 italic">Gunakan koma untuk memisahkan nilai (contoh: 10,20,30)</p>
        </div>

        <div class="flex flex-col gap-3 mt-3">
          <!-- Dropdown Arah -->
          <select id="sortDirection"
            class="border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-2 focus:ring-sky-400 outline-none">
            <option value="asc">Ascending</option>
            <option value="desc">Descending</option>
          </select>

          <!-- Tombol Sort & Sorted -->
          <div class="flex gap-3">
            <button id="sortedBtn"
              class="flex-1 py-2 rounded-md text-sm font-semibold text-white bg-gradient-to-r from-blue-500 to-sky-500 hover:scale-105 transition-transform">Sorted</button>

            <button id="sortBtn"
              class="flex-1 py-2 rounded-md text-sm font-semibold text-white bg-gradient-to-r from-blue-500 to-sky-500 hover:scale-105 transition-transform">Sort</button>
          </div>
        </div>

        <!-- Kecepatan Sorting -->
        <div class="flex flex-col gap-2 mt-3">
          <label for="speedSlider" class="text-sm font-medium text-gray-700">Kecepatan Sorting:</label>
          <input type="range" id="speedSlider" min="0.1" max="2.0" value="1.0" step="0.1"
            class="w-full transition-all focus:ring-2 focus:ring-sky-400 outline-none" />
          <p id="speedLabel" class="text-xs text-gray-500 italic">1.0</p>
        </div>

        <!-- Progress Controls -->
        <div class="flex flex-col gap-3 mt-3 pb-3 border-b border-gray-200">
          <label class="text-sm font-medium text-gray-700">Kontrol Progress:</label>
          <div class="flex gap-2">
            <button id="playPauseBtn" disabled
              class="flex-1 py-2 rounded-md text-sm font-semibold text-white bg-gradient-to-r from-green-500 to-emerald-500 hover:scale-105 transition-transform disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100">
              ▶ Play
            </button>
            <button id="stopBtn" disabled
              class="flex-1 py-2 rounded-md text-sm font-semibold text-white bg-gradient-to-r from-red-500 to-rose-500 hover:scale-105 transition-transform disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100">
              ■ Stop
            </button>
          </div>
          <div class="flex gap-2">
            <button id="prevBtn" disabled
              class="flex-1 py-2 rounded-md text-sm font-semibold text-white bg-gradient-to-r from-gray-500 to-slate-500 hover:scale-105 transition-transform disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100">
              ⏮ Prev
            </button>
            <button id="nextBtn" disabled
              class="flex-1 py-2 rounded-md text-sm font-semibold text-white bg-gradient-to-r from-gray-500 to-slate-500 hover:scale-105 transition-transform disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100">
              Next ⏭
            </button>
          </div>
        </div>

        <!-- Progress Info -->
        <div
          class="flex flex-col gap-3 mt-3 p-4 bg-gradient-to-br from-blue-50 to-sky-50 rounded-lg border border-blue-200">
          <div class="text-lg font-semibold text-blue-700 mb-1">Progress Sorting</div>

          <div class="flex flex-col gap-2 text-sm">
            <div class="flex justify-between">
              <span class="text-gray-600">Status:</span>
              <span id="statusText" class="font-semibold text-blue-600">Siap</span>
            </div>

            <div class="flex justify-between">
              <span class="text-gray-600">Pass:</span>
              <span id="passText" class="font-semibold text-gray-800">-</span>
            </div>

            <div class="flex justify-between">
              <span class="text-gray-600">Key:</span>
              <span id="keyText" class="font-semibold text-red-600">-</span>
            </div>

            <div class="flex justify-between">
              <span class="text-gray-600">Comparing:</span>
              <span id="compareText" class="font-semibold text-green-600">-</span>
            </div>

            <div class="flex justify-between">
              <span class="text-gray-600">Action:</span>
              <span id="actionText" class="font-semibold text-purple-600">-</span>
            </div>
          </div>

          <!-- Progress Bar -->
          <div class="mt-2">
            <div class="flex justify-between text-xs text-gray-600 mb-1">
              <span>Progress</span>
              <span id="progressPercent">0%</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
              <div id="progressBar" class="h-full bg-gradient-to-r from-blue-500 to-sky-500 transition-all duration-300"
                style="width: 0%"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="script.js"></script>
  <script src="transform.js"></script>
  <script src="transform_komposit.js"></script>

  <script>
    function setupCanvas(canvas) {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      return canvas.getContext("2d");
    }

    const canvas = document.getElementById("canva1");
    let ctx = setupCanvas(canvas);

    const colorData = {
      blue: { r: 109, g: 197, b: 255 },
      orange: { r: 255, g: 165, b: 0 },
      merah: { r: 255, g: 102, b: 102 },
      hijau: { r: 144, g: 238, b: 144 },
    };

    var cnv = canvas;

    const btnManyDuplicate = document.getElementById("manyDuplicateBtn");
    const btnUnique = document.getElementById("uniqueBtn");

    const inputN = document.getElementById("inputN");
    const inputA = document.getElementById("inputA");

    const sortDirection = document.getElementById("sortDirection");
    const sortBtn = document.getElementById("sortBtn");
    const sortedBtn = document.getElementById("sortedBtn");

    const speedSlider = document.getElementById("speedSlider");
    const speedLabel = document.getElementById("speedLabel");

    const playPauseBtn = document.getElementById("playPauseBtn");
    const stopBtn = document.getElementById("stopBtn");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");

    const statusText = document.getElementById("statusText");
    const passText = document.getElementById("passText");
    const keyText = document.getElementById("keyText");
    const compareText = document.getElementById("compareText");
    const actionText = document.getElementById("actionText");
    const progressPercent = document.getElementById("progressPercent");
    const progressBar = document.getElementById("progressBar");

    const width = ctx.canvas.getBoundingClientRect().width;
    const height = ctx.canvas.getBoundingClientRect().height;

    let liftAmounts = {};
    let horizontalShifts = {};
    let keyLift = 0;
    let keyShift = 0;
    let keyBaseX = 0;
    let keyValue = null;
    let initialKeyPos = -1;

    let liftTarget = 0;
    const liftMargin = 50;
    const animationDuration = 300;
    let pauseDuration = 200;

    const basePause = 200;

    speedSlider.addEventListener("input", function (e) {
      const val = parseFloat(e.target.value);
      speedLabel.textContent = val.toFixed(1);
      pauseDuration = Math.round(basePause / val);
    });

    function drawBars(ctx, data, orangeIndices = new Set(), currentKey = -1, currentCompare = -1) {
      ctx.clearRect(0, 0, width, height);

      if (data.length === 0) {
        return { dataBar: [], centerBar: [] };
      }
      let imageDataA = ctx.getImageData(0, 0, width, height);

      const barWidth = 30;
      const spacing = 15;

      const totalWidth = data.length * barWidth + (data.length - 1) * spacing;
      const availableWidth = width * 0.9;

      let scale = 1.0;
      if (totalWidth > availableWidth) {
        scale = availableWidth / totalWidth;
      }
      const s = { x: scale, y: 1.0 };

      const offsetY = height * 0.93;
      const titik_putar = { x: width / 2, y: offsetY };

      const startX = (width - totalWidth) / 2;
      const maxValue = Math.max(...data.filter(v => v !== null), keyValue !== null ? keyValue : 0) > 0 ? Math.max(...data.filter(v => v !== null), keyValue !== null ? keyValue : 0) : 1;
      const scaleHeight = (height * 0.4) / maxValue;

      let barNumber = [];
      var centerBar = [];
      var dataBar = [];

      for (let i = 0; i < data.length; i++) {
        const value = data[i];
        if (value === null) {
          continue;
        }

        const barHeight = value * scaleHeight;

        const baseX = Math.floor(startX + i * (barWidth + spacing));
        const y1_base = Math.floor(offsetY - barHeight);
        const x2_base = Math.floor(baseX + barWidth);
        const y2_base = Math.floor(offsetY);

        const currentHorizontal = horizontalShifts[i] || 0;
        const currentLift = liftAmounts[i] || 0;
        let m = createTranslation(currentHorizontal, currentLift);

        let p1_base = { x: baseX, y: y1_base };
        let p2_base = { x: x2_base, y: y2_base };
        let text_base = { x: baseX + barWidth / 2, y: offsetY + 15 };

        let p1_transform = transform_titik(p1_base, m);
        let p2_transform = transform_titik(p2_base, m);
        let text_transform = transform_titik(text_base, m);

        p1_transform = skalaFP(p1_transform, titik_putar, s);
        p2_transform = skalaFP(p2_transform, titik_putar, s);
        text_transform = skalaFP(text_transform, titik_putar, s);

        const x1 = Math.floor(p1_transform.x);
        const y1 = Math.floor(p1_transform.y);
        const x2 = Math.floor(p2_transform.x);
        const y2 = Math.floor(p2_transform.y);

        let color = colorData.blue;
        if (orangeIndices.has(i)) {
          color = colorData.orange;
        }
        if (i === currentCompare) {
          color = colorData.hijau;
        }

        dataBar.push({ x1: x1, y1: y1, x2: x2, y2: y2, color });

        bar(imageDataA, { x1: x1, y1: y1, x2: x2, y2: y2 }, 0, 0, 0);

        const fillX = Math.floor((x1 + x2) / 2);
        const fillY = Math.floor((y1 + y2) / 2);
        centerBar.push({ x: fillX, y: fillY });

        const toFlood = { r: 0, g: 0, b: 0, a: 0 };
        if (fillX > x1 && fillX < x2 && fillY > y1 && fillY < y2) {
          floodFillStack(imageDataA, ctx.canvas, fillX, fillY, toFlood, color);
        }

        barNumber.push({
          text: value,
          x: text_transform.x,
          y: text_transform.y,
        });
      }

      // Draw the key separately if exists
      if (keyValue !== null) {
        const barHeight = keyValue * scaleHeight;

        const baseX = keyBaseX;
        const y1_base = Math.floor(offsetY - barHeight);
        const x2_base = Math.floor(baseX + barWidth);
        const y2_base = Math.floor(offsetY);

        let m = createTranslation(keyShift, keyLift);

        let p1_base = { x: baseX, y: y1_base };
        let p2_base = { x: x2_base, y: y2_base };
        let text_base = { x: baseX + barWidth / 2, y: offsetY + 15 };

        let p1_transform = transform_titik(p1_base, m);
        let p2_transform = transform_titik(p2_base, m);
        let text_transform = transform_titik(text_base, m);

        p1_transform = skalaFP(p1_transform, titik_putar, s);
        p2_transform = skalaFP(p2_transform, titik_putar, s);
        text_transform = skalaFP(text_transform, titik_putar, s);

        const x1 = Math.floor(p1_transform.x);
        const y1 = Math.floor(p1_transform.y);
        const x2 = Math.floor(p2_transform.x);
        const y2 = Math.floor(p2_transform.y);

        let color = colorData.merah; // Key is always red

        dataBar.push({ x1: x1, y1: y1, x2: x2, y2: y2, color });

        bar(imageDataA, { x1: x1, y1: y1, x2: x2, y2: y2 }, 0, 0, 0);

        const fillX = Math.floor((x1 + x2) / 2);
        const fillY = Math.floor((y1 + y2) / 2);
        centerBar.push({ x: fillX, y: fillY });

        const toFlood = { r: 0, g: 0, b: 0, a: 0 };
        if (fillX > x1 && fillX < x2 && fillY > y1 && fillY < y2) {
          floodFillStack(imageDataA, ctx.canvas, fillX, fillY, toFlood, color);
        }

        barNumber.push({
          text: keyValue,
          x: text_transform.x,
          y: text_transform.y,
        });
      }

      ctx.putImageData(imageDataA, 0, 0);
      ctx.fillStyle = "#000";
      ctx.font = "14px Arial";
      ctx.textAlign = "center";

      barNumber.forEach((numberInfo) => {
        ctx.fillText(numberInfo.text, numberInfo.x, numberInfo.y);
      });

      return { dataBar, centerBar };
    }

    var dB, cB;
    let data = [];
    for (let i = 0; i < 5; i++) {
      data.push(Math.floor(Math.random() * 50));
    }
    drawBars(ctx, data);

    inputN.addEventListener("input", function (e) {
      if (isSorting) {
        return;
      }
      var n = parseInt(e.target.value);
      n = Math.min(n, 50);
      if (n > 0) {
        data = [];
        for (var i = 0; i < n; i++) {
          data.push(Math.floor(Math.random() * 50));
        }
      } else {
        data = [];
      }

      drawBars(ctx, data);
    });

    inputA.addEventListener("input", function (e) {
      if (isSorting) {
        return;
      }
      var teks = e.target.value;
      var nilai = teks.split(",");
      data = [];
      for (var i = 0; i < nilai.length; i++) {
        var angka = parseFloat(nilai[i]);
        if (!isNaN(angka)) {
          data.push(angka);
        }
      }

      drawBars(ctx, data);
    });

    btnManyDuplicate.addEventListener("click", function () {
      if (isSorting) {
        return;
      }
      var n = parseInt(inputN.value);
      var range = Math.ceil(n / 2);
      if (range < 1) {
        range = 1;
      }
      data = [];
      for (var i = 0; i < n; i++) {
        data.push(Math.floor(Math.random() * range));
      }
      drawBars(ctx, data);
    });

    btnUnique.addEventListener("click", function () {
      if (isSorting) {
        return;
      }
      var n = parseInt(inputN.value);
      var maxValue = n * 2;
      var unik = [];
      while (unik.length < n) {
        var acak = Math.floor(Math.random() * maxValue) + 1;
        if (unik.indexOf(acak) === -1) {
          unik.push(acak);
        }
      }
      data = unik;

      drawBars(ctx, data);
    });

    let isSorting = false;
    let isPaused = false;
    let p = 1;
    let i = 0;
    let tem;
    let N = 0;
    let currentDir = "asc";
    let state = "chooseBar";

    let arr_A = [];
    let orangeIndices = new Set();
    let currentCompare = -1;

    function updateProgressInfo() {
      if (!isSorting) {
        statusText.textContent = "Siap";
        passText.textContent = "-";
        keyText.textContent = "-";
        compareText.textContent = "-";
        actionText.textContent = "-";
        progressPercent.textContent = "0%";
        progressBar.style.width = "0%";
        return;
      }

      statusText.textContent = isPaused ? "Dijeda" : "Berjalan";
      passText.textContent = `${p} / ${N - 1}`;
      keyText.textContent = keyValue !== null ? keyValue : "-";
      compareText.textContent = currentCompare >= 0 ? arr_A[currentCompare] : "-";

      if (state === "chooseBar") {
        actionText.textContent = "Memilih key";
      } else if (state === "compare") {
        actionText.textContent = "Membandingkan";
      } else if (state === "moveBar") {
        actionText.textContent = "Menggeser bar";
      } else if (state === "insert") {
        actionText.textContent = "Menempatkan key";
      }

      const progress = N > 1 ? ((p - 1) / (N - 1)) * 100 : 0;
      progressPercent.textContent = `${Math.round(progress)}%`;
      progressBar.style.width = `${progress}%`;
    }

    function animateLift(targets, targetLift, callback = null) {
      let animationStartTime = performance.now();
      const initialLifts = {};
      targets.forEach(index => {
        initialLifts[index] = liftAmounts[index] || 0;
      });

      function animate() {
        const elapsed = performance.now() - animationStartTime;
        const progress = Math.min(elapsed / animationDuration, 1);
        const ease = progress * (2 - progress);

        targets.forEach(index => {
          const start = initialLifts[index];
          liftAmounts[index] = start + (targetLift - start) * ease;
        });

        drawBars(ctx, arr_A, orangeIndices, -1, currentCompare);

        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          targets.forEach(index => {
            liftAmounts[index] = targetLift;
            if (targetLift === 0) {
              delete liftAmounts[index];
            }
          });
          if (callback) {
            callback();
          }
        }
      }

      requestAnimationFrame(animate);
    }

    function animateHorizontal(targets, targetShift, callback = null) {
      let animationStartTime = performance.now();
      const initialShifts = {};
      targets.forEach(index => {
        initialShifts[index] = horizontalShifts[index] || 0;
      });

      function animate() {
        const elapsed = performance.now() - animationStartTime;
        const progress = Math.min(elapsed / animationDuration, 1);
        const ease = progress * (2 - progress);

        targets.forEach(index => {
          const start = initialShifts[index];
          horizontalShifts[index] = start + (targetShift - start) * ease;
        });

        drawBars(ctx, arr_A, orangeIndices, -1, currentCompare);

        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          targets.forEach(index => {
            horizontalShifts[index] = targetShift;
            if (targetShift === 0) {
              delete horizontalShifts[index];
            }
          });
          if (callback) {
            callback();
          }
        }
      }

      requestAnimationFrame(animate);
    }

    function animateKeyLift(targetLift, callback = null) {
      let animationStartTime = performance.now();
      const initialLift = keyLift;

      function animate() {
        const elapsed = performance.now() - animationStartTime;
        const progress = Math.min(elapsed / animationDuration, 1);
        const ease = progress * (2 - progress);

        keyLift = initialLift + (targetLift - initialLift) * ease;

        drawBars(ctx, arr_A, orangeIndices, -1, currentCompare);

        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          keyLift = targetLift;
          if (callback) {
            callback();
          }
        }
      }

      requestAnimationFrame(animate);
    }

    function animateKeyHorizontal(targetShift, callback = null) {
      let animationStartTime = performance.now();
      const initialShift = keyShift;

      function animate() {
        const elapsed = performance.now() - animationStartTime;
        const progress = Math.min(elapsed / animationDuration, 1);
        const ease = progress * (2 - progress);

        keyShift = initialShift + (targetShift - initialShift) * ease;

        drawBars(ctx, arr_A, orangeIndices, -1, currentCompare);

        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          keyShift = targetShift;
          if (callback) {
            callback();
          }
        }
      }

      requestAnimationFrame(animate);
    }

    function insertionSortStep() {
      if (!isSorting || isPaused) {
        return;
      }

      updateProgressInfo();

      const barWidth = 30;
      const spacing = 15;
      const dx = barWidth + spacing;

      if (state === "chooseBar") {
        if (p >= N) {
          // Reset all
          animateKeyLift(0, () => {
            animateLift(Object.keys(liftAmounts).map(Number), 0, () => {
              isSorting = false;
              isPaused = false;
              sortBtn.disabled = false;
              sortedBtn.disabled = false;
              playPauseBtn.disabled = true;
              stopBtn.disabled = true;
              prevBtn.disabled = true;
              nextBtn.disabled = true;
              playPauseBtn.textContent = "▶ Play";
              data = arr_A;
              liftAmounts = {};
              horizontalShifts = {};
              keyValue = null;
              updateProgressInfo();
              drawBars(ctx, data);
            });
          });
          return;
        }

        initialKeyPos = p;
        const totalWidth = N * barWidth + (N - 1) * spacing;
        const startX = (width - totalWidth) / 2;
        keyBaseX = startX + p * (barWidth + spacing);
        tem = arr_A[p];
        keyValue = tem;
        arr_A[p] = null;
        keyShift = 0;
        keyLift = 0;

        currentCompare = -1;

        // Calculate dynamic liftTarget
        const maxValue = Math.max(...arr_A.filter(v => v !== null), keyValue) > 0 ? Math.max(...arr_A.filter(v => v !== null), keyValue) : 1;
        const scaleHeight = (height * 0.4) / maxValue;
        const maxBarHeight = maxValue * scaleHeight;
        liftTarget = - (maxBarHeight + liftMargin);

        animateKeyLift(liftTarget, () => {
          setTimeout(insertionSortStep, pauseDuration);
        });

        i = p - 1;
        state = "compare";

        drawBars(ctx, arr_A, orangeIndices, -1, currentCompare);
        return;
      } else if (state === "compare") {
        let conditionMet = false;

        if (i >= 0) {
          currentCompare = i;

          // No lift for compare bar
          setTimeout(insertionSortStep, pauseDuration);

          conditionMet = currentDir === "asc" ? keyValue < arr_A[i] : keyValue > arr_A[i];
        } else {
          setTimeout(insertionSortStep, pauseDuration);
        }

        drawBars(ctx, arr_A, orangeIndices, -1, currentCompare);

        if (conditionMet) {
          state = "moveBar";
        } else {
          state = "insert";
        }
        return;
      } else if (state === "moveBar") {
        // Shift bar at i to right (to i+1)
        horizontalShifts[i] = horizontalShifts[i] || 0;

        // Animate bar shift to right
        animateHorizontal([i], dx, () => {
          arr_A[i + 1] = arr_A[i];
          arr_A[i] = null;
          horizontalShifts[i + 1] = 0;
          delete horizontalShifts[i];

          orangeIndices.add(i + 1);

          i = i - 1;
          currentCompare = -1;

          setTimeout(insertionSortStep, pauseDuration);
        });

        // Simultaneously shift key to left
        const newKeyShift = keyShift - dx;
        animateKeyHorizontal(newKeyShift);

        state = "compare";
        return;
      } else if (state === "insert") {
        const targetPos = i + 1;
        const targetDx = (targetPos - initialKeyPos) * dx;

        animateKeyHorizontal(targetDx, () => {
          // Transfer key to array bar
          arr_A[targetPos] = keyValue;
          liftAmounts[targetPos] = keyLift;
          horizontalShifts[targetPos] = 0; // Set to 0 since base position is correct
          orangeIndices.add(targetPos);
          if (i >= 0) {
            orangeIndices.add(i);
          }
          keyValue = null;
          keyShift = 0;
          keyLift = 0;

          // Animate the inserted bar down
          animateLift([targetPos], 0, () => {
            delete liftAmounts[targetPos];
            delete horizontalShifts[targetPos];

            currentCompare = -1;

            p = p + 1;
            state = "chooseBar";

            setTimeout(insertionSortStep, pauseDuration);
          });
        });
        return;
      }
    }

    function insertionSort(A, direction) {
      var N = A.length;
      for (var p = 1; p < N; p++) {
        var tem = A[p];
        var i = p - 1;

        if (direction === "asc") {
          while (i >= 0 && tem < A[i]) {
            A[i + 1] = A[i];
            i = i - 1;
          }
          A[i + 1] = tem;
        } else {
          while (i >= 0 && tem > A[i]) {
            A[i + 1] = A[i];
            i = i - 1;
          }
          A[i + 1] = tem;
        }
      }
      return A;
    }

    function applySortFromDropdown(type) {
      if (!data || data.length === 0 || isSorting) {
        return;
      }

      currentDir = sortDirection.value;

      if (type === "sorted") {
        let arr = [...data];
        insertionSort(arr, currentDir);
        data = arr;
        drawBars(ctx, data);
      } else {
        isSorting = true;
        isPaused = false;
        sortBtn.disabled = true;
        sortedBtn.disabled = true;
        playPauseBtn.disabled = false;
        stopBtn.disabled = false;
        prevBtn.disabled = false;
        nextBtn.disabled = false;
        playPauseBtn.textContent = "⏸ Pause";

        arr_A = [...data];
        N = arr_A.length;
        p = 1;
        state = "chooseBar";

        orangeIndices = new Set([0]);
        currentCompare = -1;
        liftAmounts = {};
        horizontalShifts = {};
        keyValue = null;

        updateProgressInfo();
        drawBars(ctx, arr_A, orangeIndices, -1, currentCompare);

        insertionSortStep();
      }
    }

    sortedBtn.addEventListener("click", function () {
      applySortFromDropdown("sorted");
    });
    sortBtn.addEventListener("click", function () {
      applySortFromDropdown("sort");
    });

    playPauseBtn.addEventListener("click", function () {
      if (!isSorting) {
        return;
      }

      isPaused = !isPaused;
      playPauseBtn.textContent = isPaused ? "▶ Play" : "⏸ Pause";

      if (!isPaused) {
        updateProgressInfo();
        insertionSortStep();
      } else {
        updateProgressInfo();
      }
    });

    stopBtn.addEventListener("click", function () {
      if (!isSorting) {
        return;
      }

      isSorting = false;
      isPaused = false;
      sortBtn.disabled = false;
      sortedBtn.disabled = false;
      playPauseBtn.disabled = true;
      stopBtn.disabled = true;
      prevBtn.disabled = true;
      nextBtn.disabled = true;
      playPauseBtn.textContent = "▶ Play";

      liftAmounts = {};
      horizontalShifts = {};
      keyValue = null;
      orangeIndices = new Set();
      currentCompare = -1;

      drawBars(ctx, data);
      updateProgressInfo();
    });

    prevBtn.addEventListener("click", function () {
      // Step backward functionality would require storing history
      // For now, we'll just implement a placeholder
      if (!isSorting || !isPaused) {
        return;
      }
      // TODO: Implement step backward
    });

    nextBtn.addEventListener("click", function () {
      if (!isSorting || !isPaused) {
        return;
      }

      // Execute one step
      isPaused = false;
      insertionSortStep();
      // Re-pause after step completes
      setTimeout(() => {
        isPaused = true;
        playPauseBtn.textContent = "▶ Play";
        updateProgressInfo();
      }, pauseDuration + animationDuration + 50);
    });
  </script>
</body>

</html>